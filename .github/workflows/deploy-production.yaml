name: Deploy to Production VPS

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "DEPLOY" to confirm the deployment'
        required: true
        type: string

env:
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/system-monitor

concurrency:
  group: production-deployment
  cancel-in-progress: true

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      valid: ${{ steps.validate.outputs.valid }}
    steps:
      - name: Validate confirmation
        id: validate
        run: |
          if [[ "${{ github.event.inputs.confirm }}" != "DEPLOY" ]]; then
            echo "Error: You must type 'DEPLOY' to confirm the deployment"
            exit 1
          fi
          
          echo "Validation passed"
          echo "valid=true" >> $GITHUB_OUTPUT

  check-ci-status:
    needs: validate
    runs-on: ubuntu-latest
    permissions:
      contents: read
      checks: read
      actions: read
    outputs:
      commit: ${{ steps.get-commit.outputs.commit }}
    steps:
      - name: Get latest commit from main
        id: get-commit
        run: |
          git clone --depth 1 https://github.com/${{ github.repository }}.git temp-repo
          cd temp-repo
          COMMIT=$(git rev-parse origin/main)
          cd .. && rm -rf temp-repo
          echo "commit=$COMMIT" >> $GITHUB_OUTPUT
          echo "Using latest main commit: $COMMIT"
      
      - name: Check CI status for this commit
        run: |
          COMMIT="${{ steps.get-commit.outputs.commit }}"
          echo "Checking CI status for commit: $COMMIT"
          
          # Получаем все check runs для этого коммита
          WORKFLOW_RUNS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/commits/$COMMIT/check-runs")
          
          # Проверяем статус каждой важной job
          BUILD_STATUS=$(echo "$WORKFLOW_RUNS" | jq -r '.check_runs[] | select(.name == "build") | .conclusion' | head -1)
          TEST_STATUS=$(echo "$WORKFLOW_RUNS" | jq -r '.check_runs[] | select(.name == "test") | .conclusion' | head -1)
          DOCKER_BUILD_STATUS=$(echo "$WORKFLOW_RUNS" | jq -r '.check_runs[] | select(.name == "docker-build") | .conclusion' | head -1)
          
          echo "Build job status: $BUILD_STATUS"
          echo "Test job status: $TEST_STATUS"
          echo "Docker build job status: $DOCKER_BUILD_STATUS"
          
          # Проверяем что все job завершились успешно
          if [[ "$BUILD_STATUS" != "success" ]] || [[ "$TEST_STATUS" != "success" ]] || [[ "$DOCKER_BUILD_STATUS" != "success" ]]; then
            echo "CI tests failed!"
            echo "Available check runs:"
            echo "$WORKFLOW_RUNS" | jq -r '.check_runs[] | "\(.name): \(.conclusion)"'
            exit 1
          fi
          
          echo "CI tests passed for commit $COMMIT"

  deploy:
    needs: [validate, check-ci-status]
    runs-on: ubuntu-latest
    environment: 
      name: production
    permissions:
      contents: read
      deployments: write
    
    steps:
    - name: Notify about deployment start
      run: |
        echo "PRODUCTION DEPLOYMENT STARTED"
        echo "Version: ${{ needs.check-ci-status.outputs.commit }}"
        echo "Deployed by: ${{ github.actor }}"
        echo "Time: $(date)"
  
    - name: Deploy to Production VPS
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.VPS_HOST_PROD }}
        username: ${{ secrets.VPS_USERNAME_PROD }}  # root
        password: ${{ secrets.VPS_PASSWORD_PROD }}  # пароль вместо ключа
        script: |
          set -e  # Exit on error
          
          echo "PRODUCTION DEPLOYMENT (using password)"
          echo "Version: ${{ needs.check-ci-status.outputs.commit }}"
          echo "Current user: $(whoami)"
          echo "Current directory: $(pwd)"
          
          # Создаем backup директорию
          BACKUP_DIR=~/system-monitor-backups/$(date +%Y%m%d_%H%M%S)
          mkdir -p $BACKUP_DIR
          echo "Backup directory created: $BACKUP_DIR"
          
          cd ~/system-monitor || mkdir -p ~/system-monitor && cd ~/system-monitor
          echo "Working directory: $(pwd)"
          
          # Backup текущей конфигурации если есть
          if [ -f docker-compose.yml ]; then
            cp docker-compose.yml $BACKUP_DIR/
            echo "Configuration backed up"
          fi
          
          # Скачиваем актуальный docker-compose
          echo "Downloading docker-compose.yml..."
          curl -o docker-compose.yml \
            https://raw.githubusercontent.com/${{ github.repository }}/main/docker-compose.yml
          
          # Логинимся в Docker Hub
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          
          # Останавливаем старый контейнер
          docker-compose down || true

          # export TAG=${{ steps.set-commit.outputs.commit }}
          
          # Обновляем образ
          export TAG=${{ needs.check-ci-status.outputs.commit }}
          export DOCKER_IMAGE=${{ secrets.DOCKER_USERNAME }}/system-monitor
          echo "Pulling image with tag: $TAG"
          docker-compose pull

          echo "Starting container..."
          docker-compose up -d
          
          # Очистка старых образов
          docker image prune -f
          
          echo "PRODUCTION DEPLOYMENT COMPLETE!"
          
          # Сохраняем информацию о деплое
          cat > $BACKUP_DIR/deploy-info.txt << EOF
          Version: ${{ needs.check-ci-status.outputs.commit }}
          Deployed by: ${{ github.actor }}
          Date: $(date)
          Workflow: ${{ github.run_id }}
          Method: password
          EOF

  health-check:
    needs: deploy
    runs-on: ubuntu-latest
    environment: 
      name: production
    permissions:
      contents: read
      deployments: write
    outputs:
      status: ${{ steps.health-check-status.outputs.status }}
    
    steps:
    - name: Health Check
      id: health-check
      continue-on-error: false
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.VPS_HOST_PROD }}
        username: ${{ secrets.VPS_USERNAME_PROD }}
        password: ${{ secrets.VPS_PASSWORD_PROD }}
        script: |
          set -e
          
          echo "==================================="
          echo "STARTING HEALTH CHECK"
          echo "==================================="
          echo "Version: ${{ needs.deploy.outputs.commit }}"
          
          # 1. Проверка запущен ли контейнер
          echo ""
          echo "1. Checking container status..."
          if docker ps | grep -q system-monitor; then
            echo "Container is running"
          else
            echo "Container is not running"
            docker ps -a | grep system-monitor || true
            exit 1
          fi
          
          # 2. Проверка времени работы (uptime)
          echo ""
          echo "2. Checking uptime..."
          UPTIME=$(docker inspect --format='{{.State.StartedAt}}' system-monitor 2>/dev/null)
          if [ $? -eq 0 ]; then
            echo "Container started at: $UPTIME"
            
            # Проверяем что контейнер работает не менее 5 секунд
            START_TIME=$(date -d "$UPTIME" +%s)
            CURRENT_TIME=$(date +%s)
            RUNTIME=$((CURRENT_TIME - START_TIME))
            
            if [ $RUNTIME -gt 5 ]; then
              echo "Container has been running for $RUNTIME seconds"
            else
              echo "Container just started ($RUNTIME seconds ago), waiting a bit..."
              sleep 5
            fi
          else
            echo "Failed to get container uptime"
            exit 1
          fi
          
          # 3. Проверка использования ресурсов
          echo ""
          echo "3. Checking resource usage..."
          
          # Получаем использование памяти
          MEM_USAGE=$(docker stats system-monitor --no-stream --format "{{.MemUsage}}" 2>/dev/null)
          if [ $? -eq 0 ]; then
            echo "Memory usage: $MEM_USAGE"
          else
            echo "Could not get memory usage"
          fi
          
          # Получаем использование CPU
          CPU_USAGE=$(docker stats system-monitor --no-stream --format "{{.CPUPerc}}" 2>/dev/null)
          if [ $? -eq 0 ]; then
            echo "CPU usage: $CPU_USAGE"
          else
            echo "Could not get CPU usage"
          fi
          
          # 4. Проверка что приложение действительно работает
          echo ""
          echo "4. Testing application functionality..."
          
          # Проверяем что процесс внутри контейнера жив
          if docker exec system-monitor ps aux 2>/dev/null | grep -q "system_monitor"; then
            echo "Application process is running inside container"
          else
            # Пробуем альтернативный способ
            if docker exec system-monitor sh -c "ls -la /usr/local/bin/ 2>/dev/null | grep -q system_monitor"; then
              echo "Application binary exists but process may not be running"
              docker exec system-monitor ps aux 2>/dev/null || echo "Cannot list processes"
            else
              echo "Application binary not found"
              exit 1
            fi
          fi
          
          # 5. Проверка логов на наличие ошибок
          echo ""
          echo "5. Checking logs for errors..."
          ERROR_COUNT=$(docker logs --tail 50 system-monitor 2>&1 | grep -i "error\|fatal\|panic" | grep -v "warn" | wc -l)
          
          if [ $ERROR_COUNT -eq 0 ]; then
            echo "No errors found in logs"
          else
            echo "Found $ERROR_COUNT potential issues in logs:"
            docker logs --tail 20 system-monitor 2>&1 | grep -i "error\|fatal\|panic" || true
          fi
          
          # Финальный вердикт
          echo ""
          echo "==================================="
          echo "HEALTH CHECK PASSED"
          echo "==================================="
          echo "Container: system-monitor"
          echo "Version: ${{ needs.deploy.outputs.commit }}"
          echo "Completed: $(date)"
      
    - name: Set health check status
      id: health-check-status
      run: |
        echo "status=success" >> $GITHUB_OUTPUT
        echo "Health check completed successfully"

  create-deployment-record:
    needs: health-check
    runs-on: ubuntu-latest
    permissions:
      contents: read
      deployments: write
    if: success()
    
    steps:
    - name: Get commit from deploy job
      id: get-commit
      run: |
        # Получаем commit из предыдущей job через needs
        COMMIT="${{ needs.deploy.outputs.commit }}"
        
        # Если пустой, пробуем получить из check-ci-status
        if [ -z "$COMMIT" ]; then
          COMMIT="${{ needs.check-ci-status.outputs.commit }}"
        fi
        
        # Если все еще пустой, получаем последний коммит из main
        if [ -z "$COMMIT" ]; then
          git clone --depth 1 https://github.com/${{ github.repository }}.git temp-repo
          cd temp-repo
          COMMIT=$(git rev-parse origin/main)
          cd .. && rm -rf temp-repo
        fi
        
        echo "commit=$COMMIT" >> $GITHUB_OUTPUT
        echo "Using commit: $COMMIT"
    
    - name: Create GitHub Deployment
      uses: actions/github-script@v7
      with:
        script: |
          const commit = '${{ steps.get-commit.outputs.commit }}';
          
          if (!commit) {
            throw new Error('Commit hash is empty!');
          }
          
          console.log(`Creating deployment for commit: ${commit}`);
          
          await github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: commit,
            environment: 'production',
            required_contexts: [],
            auto_merge: false,
            description: `Deployed version ${commit} with health check passed`
          });
          
    - name: Deployment Success Notification
      run: |
        echo "Production deployment completed successfully!"
        echo "Version: ${{ steps.get-commit.outputs.commit }}"
        echo "Health check: PASSED"
        echo "Deployment record created in GitHub"